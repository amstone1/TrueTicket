generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id                String    @id @default(cuid())
  email             String?   @unique
  phone             String?   @unique
  walletAddress     String?   @unique
  privyUserId       String?   @unique

  // Authentication
  passwordHash      String?
  role              UserRole  @default(USER)

  // Email verification
  emailVerified     Boolean   @default(false)
  emailVerifyToken  String?
  emailVerifyExpiry DateTime?

  // Password reset
  resetToken        String?
  resetTokenExpiry  DateTime?

  // Profile
  displayName       String?
  firstName         String?
  lastName          String?
  avatarUrl         String?
  bio               String?

  // WebAuthn credentials (for device biometric login)
  webAuthnCredentials WebAuthnCredential[]

  // Face template for venue check-in (stored as hash, never raw biometric)
  faceTemplateHash    String?
  faceTemplateVersion Int?
  faceEnrolledAt      DateTime?

  // ZK verification preferences
  zkVerificationEnabled Boolean @default(false)
  biometricCommitment   String? // Poseidon hash commitment for ZK proofs

  // Legacy flags (kept for compatibility)
  isVerified        Boolean   @default(false)
  isArtist          Boolean   @default(false)
  isVenue           Boolean   @default(false)
  isAdmin           Boolean   @default(false)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastLoginAt       DateTime?

  // Sessions for refresh token tracking
  sessions          Session[]

  ownedTickets      Ticket[]  @relation("TicketOwner")
  createdEvents     Event[]   @relation("EventOrganizer")
  resaleListings    ResaleListing[] @relation("ListingSeller")
  purchases         Purchase[]
  payouts           Payout[]
  notifications     Notification[]
  favoriteEvents    EventFavorite[]

  @@index([walletAddress])
  @@index([email])
  @@index([faceTemplateHash])
}

enum UserRole {
  USER
  ORGANIZER
  VENUE
  ARTIST
  ADMIN
}

model Session {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  refreshToken  String    @unique
  userAgent     String?
  ipAddress     String?
  isValid       Boolean   @default(true)

  createdAt     DateTime  @default(now())
  expiresAt     DateTime
  lastUsedAt    DateTime  @default(now())

  @@index([userId])
  @@index([refreshToken])
}

// ============================================
// WEBAUTHN CREDENTIALS (Device Biometric Login)
// ============================================

model WebAuthnCredential {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // WebAuthn credential data
  credentialId    String   @unique // Base64 encoded credential ID
  publicKey       String            // Base64 encoded public key (COSE format)
  counter         BigInt   @default(0) // Signature counter for replay protection

  // Credential metadata
  deviceType      String?  // "platform" (built-in) or "cross-platform" (security key)
  transports      String   @default("[]") // JSON array: ["internal", "usb", "ble", "nfc"]
  aaguid          String?  // Authenticator Attestation GUID

  // Device info for user management
  deviceName      String?  // User-friendly name like "iPhone 15 Pro"
  userAgent       String?

  // Status
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  lastUsedAt      DateTime @default(now())

  @@index([userId])
  @@index([credentialId])
}

// ============================================
// EVENTS
// ============================================

model Event {
  id                  String    @id @default(cuid())

  contractAddress     String?
  chainId             Int       @default(137)
  eventIdOnChain      BigInt?

  name                String
  slug                String    @unique
  description         String
  shortDescription    String?

  category            EventCategory
  tags                String    @default("[]") // JSON array

  startDate           DateTime
  endDate             DateTime?
  doorsOpen           DateTime?
  timezone            String    @default("America/New_York")

  locationType        LocationType @default(IN_PERSON)
  venueName           String?
  venueAddress        String?
  city                String?
  state               String?
  country             String?
  postalCode          String?
  latitude            Float?
  longitude           Float?
  virtualUrl          String?

  coverImageUrl       String?
  coverImageIpfsHash  String?
  thumbnailUrl        String?
  galleryImages       Json?

  totalCapacity       Int

  resaleEnabled       Boolean   @default(true)
  maxResaleMarkupBps  Int?      // Max markup in basis points (1000 = 10%)
  resaleRoyaltyBps    Int       @default(1000) // 10% default royalty

  artistWallet        String?
  venueWallet         String?
  hostWallet          String?
  artistRoyaltyBps    Int       @default(5000) // 50% of royalty to artist
  venueRoyaltyBps     Int       @default(3000) // 30% to venue
  hostRoyaltyBps      Int       @default(1500) // 15% to host
  platformRoyaltyBps  Int       @default(500)  // 5% to platform

  status              EventStatus @default(DRAFT)
  isPublished         Boolean   @default(false)
  isFeatured          Boolean   @default(false)
  publishedAt         DateTime?

  organizerId         String
  organizer           User      @relation("EventOrganizer", fields: [organizerId], references: [id])

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  ticketTiers         TicketTier[]
  tickets             Ticket[]
  resaleListings      ResaleListing[]
  purchases           Purchase[]
  favorites           EventFavorite[]
  checkIns            CheckIn[]

  // ZK Merkle tree for privacy-preserving ticket verification
  zkMerkleTree        ZKMerkleTree?

  @@index([organizerId])
  @@index([status])
  @@index([startDate])
  @@index([city, state])
  @@index([category])
  @@index([slug])
  @@index([contractAddress])
}

model TicketTier {
  id                String    @id @default(cuid())
  eventId           String
  event             Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  name              String
  description       String?

  priceUsd          Float
  priceMatic        Float?

  totalQuantity     Int
  soldQuantity      Int       @default(0)
  reservedQuantity  Int       @default(0)

  maxPerWallet      Int       @default(10)

  saleStartDate     DateTime?
  saleEndDate       DateTime?

  perks             String    @default("[]") // JSON array

  ticketImageUrl    String?
  ticketImageIpfs   String?
  metadataUri       String?

  isActive          Boolean   @default(true)
  tierIdOnChain     BigInt?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  tickets           Ticket[]

  @@index([eventId])
}

enum EventCategory {
  MUSIC
  SPORTS
  ARTS
  THEATER
  COMEDY
  CONFERENCE
  FESTIVAL
  NETWORKING
  OTHER
}

enum LocationType {
  IN_PERSON
  VIRTUAL
  HYBRID
}

enum EventStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
  CANCELLED
  COMPLETED
}

// ============================================
// TICKETS
// ============================================

model Ticket {
  id                String    @id @default(cuid())

  tokenId           BigInt?
  contractAddress   String?
  chainId           Int       @default(137)
  mintTxHash        String?

  eventId           String
  event             Event     @relation(fields: [eventId], references: [id])
  tierId            String
  tier              TicketTier @relation(fields: [tierId], references: [id])
  ownerId           String
  owner             User      @relation("TicketOwner", fields: [ownerId], references: [id])

  metadataUri       String?
  imageUri          String?

  status            TicketStatus @default(VALID)
  isListed          Boolean   @default(false)

  checkInCode       String?   @unique
  checkInCodeHash   String?

  purchaseId        String?
  originalPriceUsd  Float

  // Biometric binding - prevents scalping by requiring biometric re-bind on transfer
  biometricBindings      BiometricBinding[]
  currentBiometricHash   String?  // Quick reference to active binding hash
  biometricBoundAt       DateTime?

  // ZK verification data
  zkMerkleLeaf           String?  // Poseidon(ticketData, salt) for Merkle tree
  zkTicketSalt           String?  // Random salt for privacy
  requiresZKVerification Boolean  @default(false)

  mintedAt          DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  resaleListings    ResaleListing[]
  checkIns          CheckIn[]
  transfers         TicketTransfer[]

  @@index([eventId])
  @@index([ownerId])
  @@index([tokenId, contractAddress])
  @@index([status])
  @@index([checkInCode])
  @@index([currentBiometricHash])
}

model TicketTransfer {
  id            String    @id @default(cuid())
  ticketId      String
  ticket        Ticket    @relation(fields: [ticketId], references: [id])

  fromAddress   String
  toAddress     String
  txHash        String?

  transferType  TransferType
  priceUsd      Float?

  createdAt     DateTime  @default(now())

  @@index([ticketId])
  @@index([txHash])
}

enum TicketStatus {
  PENDING_MINT
  VALID
  USED
  EXPIRED
  REVOKED
  TRANSFERRED
}

enum TransferType {
  MINT
  PURCHASE
  RESALE
  GIFT
  TRANSFER
}

// ============================================
// RESALE MARKETPLACE
// ============================================

model ResaleListing {
  id              String    @id @default(cuid())

  ticketId        String
  ticket          Ticket    @relation(fields: [ticketId], references: [id])
  eventId         String
  event           Event     @relation(fields: [eventId], references: [id])
  sellerId        String
  seller          User      @relation("ListingSeller", fields: [sellerId], references: [id])

  priceUsd        Float
  priceMatic      Float?

  status          ListingStatus @default(ACTIVE)

  listingIdOnChain BigInt?
  listingTxHash    String?

  listedAt        DateTime  @default(now())
  expiresAt       DateTime?
  soldAt          DateTime?
  cancelledAt     DateTime?

  buyerId         String?
  purchaseId      String?

  @@index([eventId])
  @@index([sellerId])
  @@index([status])
  @@index([ticketId])
}

enum ListingStatus {
  ACTIVE
  SOLD
  CANCELLED
  EXPIRED
}

// ============================================
// PURCHASES & PAYMENTS
// ============================================

model Purchase {
  id                  String    @id @default(cuid())

  userId              String
  user                User      @relation(fields: [userId], references: [id])

  eventId             String
  event               Event     @relation(fields: [eventId], references: [id])

  paymentMethod       PaymentMethod
  paymentProvider     String?

  stripePaymentIntentId String? @unique
  stripeSessionId     String?

  cryptoTxHash        String?
  cryptoCurrency      String?
  cryptoAmount        String?

  subtotalUsd         Float
  feesUsd             Float
  totalUsd            Float

  sponsoredGas        Boolean   @default(false)
  gasSponsored        String?

  status              PurchaseStatus @default(PENDING)

  ticketQuantity      Int
  ticketIds           String    @default("[]") // JSON array

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  completedAt         DateTime?
  refundedAt          DateTime?

  @@index([userId])
  @@index([eventId])
  @@index([status])
  @@index([stripePaymentIntentId])
}

enum PaymentMethod {
  CREDIT_CARD
  CRYPTO_MATIC
  CRYPTO_USDC
  CRYPTO_ETH
  FREE
}

enum PurchaseStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

// ============================================
// PAYOUTS
// ============================================

model Payout {
  id                String    @id @default(cuid())

  userId            String
  user              User      @relation(fields: [userId], references: [id])

  amountUsd         Float
  amountCrypto      String?
  currency          String    @default("USD")

  payoutMethod      PayoutMethod

  stripeTransferId  String?
  stripeAccountId   String?

  cryptoTxHash      String?
  cryptoAddress     String?

  status            PayoutStatus @default(PENDING)

  sourceType        String
  sourceIds         String    @default("[]") // JSON array

  createdAt         DateTime  @default(now())
  processedAt       DateTime?

  @@index([userId])
  @@index([status])
}

enum PayoutMethod {
  STRIPE_CONNECT
  CRYPTO_MATIC
  CRYPTO_USDC
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================
// CHECK-INS
// ============================================

model CheckIn {
  id            String    @id @default(cuid())

  ticketId      String
  ticket        Ticket    @relation(fields: [ticketId], references: [id])
  eventId       String
  event         Event     @relation(fields: [eventId], references: [id])

  method        CheckInMethod

  gate          String?
  scannedBy     String?

  deviceId      String?
  ipAddress     String?

  status        CheckInStatus @default(SUCCESS)
  failureReason String?

  txHash        String?

  // Biometric verification at check-in
  biometricVerified   Boolean  @default(false)
  biometricMatchScore Float?   // 0.0 - 1.0 confidence score
  biometricMethod     BiometricCheckInMethod?
  livenessVerified    Boolean  @default(false)

  // ZK proof verification
  zkProofVerified     Boolean  @default(false)
  zkProofHash         String?  // Hash of the ZK proof for audit

  checkedInAt   DateTime  @default(now())

  @@index([ticketId])
  @@index([eventId])
}

enum CheckInMethod {
  QR_CODE
  NFC
  MANUAL
  WALLET_SIGNATURE
  ZK_PROOF
}

enum BiometricCheckInMethod {
  FACE_SCAN
  WEBAUTHN_CHALLENGE
}

enum CheckInStatus {
  SUCCESS
  FAILED_INVALID
  FAILED_ALREADY_USED
  FAILED_WRONG_EVENT
  FAILED_EXPIRED
}

// ============================================
// BLOCKCHAIN SYNC
// ============================================

model BlockchainSync {
  id                String    @id @default(cuid())

  chainId           Int
  contractAddress   String
  lastBlockNumber   BigInt
  lastBlockHash     String?

  eventType         String

  status            SyncStatus @default(SYNCING)
  errorMessage      String?

  updatedAt         DateTime  @updatedAt

  @@unique([chainId, contractAddress, eventType])
  @@index([chainId, contractAddress])
}

model BlockchainTransaction {
  id                String    @id @default(cuid())

  txHash            String    @unique
  chainId           Int

  fromAddress       String
  toAddress         String?

  status            TxStatus  @default(PENDING)
  blockNumber       BigInt?
  gasUsed           String?

  isMetaTx          Boolean   @default(false)
  relayerAddress    String?
  userOpHash        String?

  purchaseId        String?
  ticketId          String?
  listingId         String?

  errorMessage      String?
  retryCount        Int       @default(0)

  createdAt         DateTime  @default(now())
  confirmedAt       DateTime?

  @@index([txHash])
  @@index([status])
  @@index([purchaseId])
}

enum SyncStatus {
  SYNCING
  SYNCED
  ERROR
  PAUSED
}

enum TxStatus {
  PENDING
  SUBMITTED
  CONFIRMED
  FAILED
  DROPPED
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id            String    @id @default(cuid())

  userId        String
  user          User      @relation(fields: [userId], references: [id])

  type          NotificationType
  title         String
  message       String
  data          Json?

  isRead        Boolean   @default(false)
  readAt        DateTime?

  emailSent     Boolean   @default(false)
  smsSent       Boolean   @default(false)
  pushSent      Boolean   @default(false)

  createdAt     DateTime  @default(now())

  @@index([userId])
  @@index([isRead])
}

enum NotificationType {
  TICKET_PURCHASED
  TICKET_MINTED
  TICKET_TRANSFERRED
  TICKET_SOLD
  EVENT_REMINDER
  EVENT_CANCELLED
  EVENT_UPDATED
  PAYOUT_COMPLETED
  LISTING_SOLD
  PRICE_DROP_ALERT
}

// ============================================
// FAVORITES
// ============================================

model EventFavorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id])
  createdAt DateTime @default(now())

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

// ============================================
// BIOMETRIC BINDING (Anti-Scalping)
// ============================================

model BiometricBinding {
  id              String        @id @default(cuid())
  ticketId        String
  ticket          Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Biometric commitment (never store raw biometrics)
  biometricHash   String        // Keccak256 hash of biometric template
  biometricType   BiometricType
  bindingVersion  Int           @default(1) // For algorithm upgrades

  // Cryptographic proof of binding
  commitmentProof String?       // Signature proving ownership at binding time
  nonce           String?       // Prevent replay attacks

  // Status tracking
  status          BindingStatus @default(ACTIVE)
  boundAt         DateTime      @default(now())
  unboundAt       DateTime?
  unboundReason   String?

  // For tracking rebinding after transfer
  previousBindingId String?

  @@unique([ticketId, status]) // Only one active binding per ticket
  @@index([ticketId])
  @@index([biometricHash])
  @@index([status])
}

enum BiometricType {
  FACE_TEMPLATE
  WEBAUTHN_CREDENTIAL
}

enum BindingStatus {
  ACTIVE
  PENDING_REBIND  // After transfer, before new owner binds
  TRANSFERRED     // Historical record
  REVOKED
}

// ============================================
// ZK VERIFICATION (Zero-Knowledge Proofs)
// ============================================

model ZKMerkleTree {
  id          String   @id @default(cuid())
  eventId     String   @unique
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Current Merkle root (updated when tickets are minted)
  merkleRoot  String
  totalLeaves Int      @default(0)

  // Serialized tree data for proof generation
  // JSON: { leaves: string[], depth: number }
  treeData    String

  // On-chain sync status
  onChainRoot String?  // Root stored on-chain
  lastSyncTx  String?  // Transaction hash of last sync

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([eventId])
  @@index([merkleRoot])
}

model ZKUsedNonce {
  id        String   @id @default(cuid())
  nonce     String   @unique
  ticketId  String
  eventId   String

  // Proof verification details
  proofHash String?  // Hash of the ZK proof for audit
  verifiedAt DateTime @default(now())
  verifiedBy String?  // Scanner ID or system

  @@index([nonce])
  @@index([ticketId])
  @@index([eventId])
}

// ============================================
// ZK PROOF LOGS (Audit Trail)
// ============================================

model ZKProofLog {
  id            String   @id @default(cuid())
  eventId       String
  ticketId      String?

  proofType     ZKProofType
  proofHash     String   @unique
  circuitName   String   // e.g., "ticket-ownership-v1"

  // Public inputs used in verification
  publicInputs  String   // JSON serialized

  // Verification result
  verified      Boolean
  verifiedOnChain Boolean @default(false)
  onChainTxHash String?

  // Metadata
  proverAddress String?  // Wallet that generated the proof
  verifierAddress String? // Contract or service that verified

  createdAt     DateTime @default(now())
  verifiedAt    DateTime?

  @@index([eventId])
  @@index([ticketId])
  @@index([proofHash])
  @@index([proofType])
}

enum ZKProofType {
  TICKET_OWNERSHIP    // Proves ownership of a ticket in the set
  BIOMETRIC_MATCH     // Proves biometric matches bound template
  COMBINED            // Both ownership and biometric in one proof
}
