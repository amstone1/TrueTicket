/**
 * Blockchain Service
 * Handles all on-chain interactions for TrueTicket
 */

import { ethers, Contract, Wallet, JsonRpcProvider } from 'ethers';
import { getChainConfig, getContractAddresses, ACTIVE_CHAIN, type ChainName } from './config';

// Import ABIs (generated by Hardhat compilation)
import EventFactoryABI from '../../../artifacts/contracts/EventFactory.sol/EventFactory.json';
import TrueTicketNFTABI from '../../../artifacts/contracts/TrueTicketNFT.sol/TrueTicketNFT.json';
import PricingControllerABI from '../../../artifacts/contracts/PricingController.sol/PricingController.json';
import MarketplaceABI from '../../../artifacts/contracts/Marketplace.sol/Marketplace.json';
import RoyaltyDistributorABI from '../../../artifacts/contracts/RoyaltyDistributor.sol/RoyaltyDistributor.json';

export interface MintTicketParams {
  eventId: number;
  recipient: string;
  tier: number;
  section?: string;
  row?: string;
  seatNumber?: number;
  originalPrice: bigint; // In wei
}

export interface TicketMetadata {
  eventId: bigint;
  section: string;
  row: string;
  seatNumber: number;
  tier: number;
  originalPrice: bigint;
  mintTimestamp: bigint;
  used: boolean;
}

export interface TransferRestriction {
  transferable: boolean;
  lockUntil: bigint;
  maxTransfers: number;
  transferCount: number;
  resaleAllowed: boolean;
}

class BlockchainService {
  private provider: JsonRpcProvider | null = null;
  private signer: Wallet | null = null;
  private chain: ChainName;
  private initialized = false;

  constructor() {
    this.chain = ACTIVE_CHAIN;
  }

  /**
   * Initialize the blockchain connection
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    const config = getChainConfig(this.chain);
    this.provider = new JsonRpcProvider(config.rpcUrl);

    // Use platform wallet for signing transactions
    const privateKey = process.env.PLATFORM_WALLET_PRIVATE_KEY;
    if (!privateKey) {
      console.warn('PLATFORM_WALLET_PRIVATE_KEY not set - blockchain operations will fail');
      return;
    }

    this.signer = new Wallet(privateKey, this.provider);
    this.initialized = true;

    console.log(`Blockchain service initialized on ${config.name} (chainId: ${config.chainId})`);
  }

  /**
   * Get the provider (read-only operations)
   */
  getProvider(): JsonRpcProvider {
    if (!this.provider) {
      const config = getChainConfig(this.chain);
      this.provider = new JsonRpcProvider(config.rpcUrl);
    }
    return this.provider;
  }

  /**
   * Get a contract instance
   */
  private getContract(address: string, abi: any, withSigner = false): Contract {
    const provider = this.getProvider();
    if (withSigner && this.signer) {
      return new Contract(address, abi, this.signer);
    }
    return new Contract(address, abi, provider);
  }

  /**
   * Get the EventFactory contract
   */
  getEventFactory(withSigner = false): Contract | null {
    const addresses = getContractAddresses(this.chain);
    if (!addresses?.eventFactory) return null;
    return this.getContract(addresses.eventFactory, EventFactoryABI.abi, withSigner);
  }

  /**
   * Get a TrueTicketNFT contract for a specific event
   */
  getTicketContract(contractAddress: string, withSigner = false): Contract {
    return this.getContract(contractAddress, TrueTicketNFTABI.abi, withSigner);
  }

  /**
   * Get the Marketplace contract
   */
  getMarketplace(withSigner = false): Contract | null {
    const addresses = getContractAddresses(this.chain);
    if (!addresses?.marketplace) return null;
    return this.getContract(addresses.marketplace, MarketplaceABI.abi, withSigner);
  }

  /**
   * Get the PricingController contract
   */
  getPricingController(withSigner = false): Contract | null {
    const addresses = getContractAddresses(this.chain);
    if (!addresses?.pricingController) return null;
    return this.getContract(addresses.pricingController, PricingControllerABI.abi, withSigner);
  }

  // ============================================
  // NFT MINTING
  // ============================================

  /**
   * Mint a ticket NFT on-chain
   */
  async mintTicket(
    ticketContractAddress: string,
    params: MintTicketParams,
    transferRestrictions?: Partial<TransferRestriction>
  ): Promise<{ tokenId: bigint; txHash: string }> {
    await this.initialize();

    if (!this.signer) {
      throw new Error('Blockchain service not initialized with signer');
    }

    const contract = this.getTicketContract(ticketContractAddress, true);

    const metadata = {
      eventId: params.eventId,
      section: params.section || '',
      row: params.row || '',
      seatNumber: params.seatNumber || 0,
      tier: params.tier,
      originalPrice: params.originalPrice,
      mintTimestamp: BigInt(0), // Set by contract
      used: false,
    };

    const restrictions = {
      transferable: transferRestrictions?.transferable ?? true,
      lockUntil: transferRestrictions?.lockUntil ?? 0n,
      maxTransfers: transferRestrictions?.maxTransfers ?? 0, // 0 = unlimited
      transferCount: 0,
      resaleAllowed: transferRestrictions?.resaleAllowed ?? true,
    };

    const tx = await contract.mint(params.recipient, metadata, restrictions);
    const receipt = await tx.wait();

    // Extract tokenId from TicketMinted event
    const mintEvent = receipt.logs.find((log: any) => {
      try {
        const parsed = contract.interface.parseLog(log);
        return parsed?.name === 'TicketMinted';
      } catch {
        return false;
      }
    });

    if (!mintEvent) {
      throw new Error('TicketMinted event not found in transaction');
    }

    const parsed = contract.interface.parseLog(mintEvent);
    const tokenId = parsed?.args.tokenId;

    return {
      tokenId,
      txHash: receipt.hash,
    };
  }

  /**
   * Batch mint tickets
   */
  async mintTicketBatch(
    ticketContractAddress: string,
    recipients: string[],
    paramsArray: MintTicketParams[],
    transferRestrictions?: Partial<TransferRestriction>
  ): Promise<{ tokenIds: bigint[]; txHash: string }> {
    await this.initialize();

    if (!this.signer) {
      throw new Error('Blockchain service not initialized with signer');
    }

    const contract = this.getTicketContract(ticketContractAddress, true);

    const metadataArray = paramsArray.map((params) => ({
      eventId: params.eventId,
      section: params.section || '',
      row: params.row || '',
      seatNumber: params.seatNumber || 0,
      tier: params.tier,
      originalPrice: params.originalPrice,
      mintTimestamp: BigInt(0),
      used: false,
    }));

    const restrictions = {
      transferable: transferRestrictions?.transferable ?? true,
      lockUntil: transferRestrictions?.lockUntil ?? 0n,
      maxTransfers: transferRestrictions?.maxTransfers ?? 0,
      transferCount: 0,
      resaleAllowed: transferRestrictions?.resaleAllowed ?? true,
    };

    const tx = await contract.mintBatch(recipients, metadataArray, restrictions);
    const receipt = await tx.wait();

    // Extract tokenIds from events
    const tokenIds: bigint[] = [];
    for (const log of receipt.logs) {
      try {
        const parsed = contract.interface.parseLog(log);
        if (parsed?.name === 'TicketMinted') {
          tokenIds.push(parsed.args.tokenId);
        }
      } catch {
        continue;
      }
    }

    return {
      tokenIds,
      txHash: receipt.hash,
    };
  }

  // ============================================
  // TICKET VERIFICATION (Anti-Screenshot)
  // ============================================

  /**
   * Generate a time-limited verification signature for check-in
   * This replaces static QR codes with cryptographic proof
   */
  async generateVerificationSignature(
    ticketContractAddress: string,
    tokenId: bigint,
    ownerAddress: string,
    validForSeconds: number = 60
  ): Promise<{
    signature: string;
    message: string;
    expiresAt: number;
    nonce: string;
  }> {
    await this.initialize();

    if (!this.signer) {
      throw new Error('Blockchain service not initialized with signer');
    }

    const expiresAt = Math.floor(Date.now() / 1000) + validForSeconds;
    const nonce = ethers.hexlify(ethers.randomBytes(16));

    // Create a message that includes all verification data
    const message = ethers.solidityPackedKeccak256(
      ['address', 'uint256', 'address', 'uint256', 'bytes16'],
      [ticketContractAddress, tokenId, ownerAddress, expiresAt, nonce]
    );

    // Sign with platform key
    const signature = await this.signer.signMessage(ethers.getBytes(message));

    return {
      signature,
      message,
      expiresAt,
      nonce,
    };
  }

  /**
   * Verify a check-in signature (called by scanner)
   */
  verifyCheckInSignature(
    ticketContractAddress: string,
    tokenId: bigint,
    ownerAddress: string,
    expiresAt: number,
    nonce: string,
    signature: string
  ): { valid: boolean; reason?: string } {
    // Check if expired
    if (Date.now() / 1000 > expiresAt) {
      return { valid: false, reason: 'Verification code expired' };
    }

    // Recreate the message
    const message = ethers.solidityPackedKeccak256(
      ['address', 'uint256', 'address', 'uint256', 'bytes16'],
      [ticketContractAddress, tokenId, ownerAddress, expiresAt, nonce]
    );

    // Recover signer from signature
    const recoveredAddress = ethers.verifyMessage(ethers.getBytes(message), signature);

    // Verify it was signed by platform wallet
    const platformAddress = process.env.PLATFORM_WALLET_ADDRESS;
    if (recoveredAddress.toLowerCase() !== platformAddress?.toLowerCase()) {
      return { valid: false, reason: 'Invalid signature' };
    }

    return { valid: true };
  }

  // ============================================
  // ON-CHAIN READS
  // ============================================

  /**
   * Get ticket metadata from chain
   */
  async getTicketMetadata(
    ticketContractAddress: string,
    tokenId: bigint
  ): Promise<TicketMetadata> {
    const contract = this.getTicketContract(ticketContractAddress);
    return await contract.getTicketMetadata(tokenId);
  }

  /**
   * Get ticket owner from chain
   */
  async getTicketOwner(ticketContractAddress: string, tokenId: bigint): Promise<string> {
    const contract = this.getTicketContract(ticketContractAddress);
    return await contract.ownerOf(tokenId);
  }

  /**
   * Check if ticket is used
   */
  async isTicketUsed(ticketContractAddress: string, tokenId: bigint): Promise<boolean> {
    const metadata = await this.getTicketMetadata(ticketContractAddress, tokenId);
    return metadata.used;
  }

  /**
   * Validate resale price on-chain
   */
  async validateResalePrice(
    eventId: number,
    tokenId: bigint,
    originalPrice: bigint,
    proposedPrice: bigint
  ): Promise<{ valid: boolean; reason: string }> {
    const pricingController = this.getPricingController();
    if (!pricingController) {
      throw new Error('PricingController not deployed');
    }

    const [valid, reason] = await pricingController.validateResalePrice(
      eventId,
      tokenId,
      originalPrice,
      proposedPrice
    );

    return { valid, reason };
  }

  /**
   * Get max resale price for a ticket
   */
  async getMaxResalePrice(
    eventId: number,
    tokenId: bigint,
    originalPrice: bigint
  ): Promise<bigint> {
    const pricingController = this.getPricingController();
    if (!pricingController) {
      throw new Error('PricingController not deployed');
    }

    return await pricingController.getMaxResalePrice(eventId, tokenId, originalPrice);
  }

  // ============================================
  // ON-CHAIN MARKETPLACE
  // ============================================

  /**
   * List ticket for sale on-chain
   */
  async listTicketOnChain(
    ticketContractAddress: string,
    tokenId: bigint,
    price: bigint,
    durationSeconds: number
  ): Promise<{ listingId: bigint; txHash: string }> {
    await this.initialize();

    const marketplace = this.getMarketplace(true);
    if (!marketplace) {
      throw new Error('Marketplace not deployed');
    }

    const tx = await marketplace.listTicket(
      ticketContractAddress,
      tokenId,
      price,
      durationSeconds
    );
    const receipt = await tx.wait();

    // Extract listingId from event
    const listEvent = receipt.logs.find((log: any) => {
      try {
        const parsed = marketplace.interface.parseLog(log);
        return parsed?.name === 'TicketListed';
      } catch {
        return false;
      }
    });

    const parsed = marketplace.interface.parseLog(listEvent);
    return {
      listingId: parsed?.args.listingId,
      txHash: receipt.hash,
    };
  }

  /**
   * Buy a listed ticket on-chain
   */
  async buyTicketOnChain(
    listingId: bigint,
    price: bigint
  ): Promise<{ txHash: string }> {
    await this.initialize();

    const marketplace = this.getMarketplace(true);
    if (!marketplace) {
      throw new Error('Marketplace not deployed');
    }

    const tx = await marketplace.buyTicket(listingId, { value: price });
    const receipt = await tx.wait();

    return { txHash: receipt.hash };
  }

  // ============================================
  // CHECK-IN (ON-CHAIN)
  // ============================================

  /**
   * Mark ticket as used on-chain
   */
  async markTicketUsed(
    ticketContractAddress: string,
    tokenId: bigint
  ): Promise<{ txHash: string }> {
    await this.initialize();

    if (!this.signer) {
      throw new Error('Blockchain service not initialized with signer');
    }

    const contract = this.getTicketContract(ticketContractAddress, true);
    const tx = await contract.markAsUsed(tokenId);
    const receipt = await tx.wait();

    return { txHash: receipt.hash };
  }
}

// Singleton instance
export const blockchainService = new BlockchainService();
